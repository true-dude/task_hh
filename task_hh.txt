Вид хранения информации на сервере.
Так как фактически пользователю постоянно нужна отсортированная по тому или иному параметру информация, то хранить ее будем в модифицированном дереве поиска. Будем использовать красно-черное дерево поиска, так как оно гарантирует логарифмическую ассимптотику и проиграывает своим конкурентам (сплей деревеву, декартову), только тем что сложнее пишеться, но так как у нас серьезный проект, то это не так важно. Модификация это дерева будет следующей: в каждой вершине дерева мы будем хранить не стандартный набор данных по типу

struct Node
{

	data val;
	struct Node* left;
	struct Node* rignt;
	struct Node* parent;


};
Фактически будем хранить K деревьев поиска в одном (K количество параметров по которым возможна сортировка

struct Node
{
	
	data* params;
	struct Node** lefts;   // [param1_left_ptr, param2_left_ptr, ... , paramK_left_ptr];
	struct Node** rignts;  // аналогично
	struct Node** parents; // аналогично
	size_t* size_tree;     // [size1, size2, ... , sizeK]
			       // sizeX - размер поддерева, вершиной которого является данная вершина в дереве с параметром X
			       // (необходим для того, чтобы ассоциировать дерево с отсортированным массиом (таблицей)
};

Вполне возможно реализовать все стандартные функции дерева поиска (удаление, вставка, поиск). Думаю, что не стоит описывать алгоритмы балансировки и обоснование ассимтотики КЧ дерева, так это можно прочитать в учебнике по алгоритмам
Альтернативная структура данных, которую можно было бы рассмотреть - это Skip-List. Он привлекателен тем, что поддерживает параллельные вычисления, но хуже тем, что не гарантирует логарифмическую ассимптотику, так как является вероятностной структурой данных

Протокол клиент-верверного взаимодействия.
В момент когда пользователь в очередной скролируется / изменяет параметр сортировки, клиет отправляет серверу запрос вида: (номер первой строки интересующей пользователя и номер параметра по которому должны быть отсортированы строки)
Сервер в свою очередь, используя не сложный обход дерева (несложный с учетом специфики дерева поиска (в левом поддереве будут узлы с меньшими либо равными значениями, в правом соответсвенно с большими и учетом того, что мы храним размеры поддеревьев), возвращает клиету отсортированный массив (таблицу), который (которую) в свою очередь клиент выводит пользователю

В момент, когда сервер модифицирует таблицу, он должен проверить на каких строках сейчас находиться пользователь (посмореть последний запрос пользователя) и в случае если при модификации таблицы изменились строки, просматриваемые пользователем, он отправляет клиенту новые данные, иначе ничего не делает, ждет новой модификации данных / запроса от клиента.
